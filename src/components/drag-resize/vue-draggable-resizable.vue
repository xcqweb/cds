<template>
  <div
    class="vdrr"
    :style="style"
    :class="{
      draggable: draggable,
      resizable: resizable,
      rotatable: rotatable,
      active: enabled,
      dragging: dragging,
      resizing: resizing,
      rotating: rotating
    }"
    @mousedown.stop="elmDown"
    @touchstart.prevent.stop="elmDown"
  >
    <slot></slot>
    <template v-if="resizable">
      <div
        v-for="(handle, index) in handles"
        class="handle"
        :key="handle"
        :class="'handle-' + handle"
        :style="{
          display: enabled ? 'block' : 'none',
          cursor: cursorStyle[index]
        }"
        @mousedown.stop.prevent="handleDown(handle, $event)"
        @touchstart.stop.prevent="handleDown(handle, $event)"
      />
    </template>
  </div>
</template>

<script>
import { matchesSelectorToParentElements } from "@u/dom"

export default {
  replace: true,
  name: "VueDraggableResizableRotatable",
  props: {
    active: {
      type: Boolean,
      default: false
    },
    draggable: {
      type: Boolean,
      default: true
    },
    resizable: {
      type: Boolean,
      default: true
    },
    rotatable: {
      type: Boolean,
      default: true
    },
    w: {
      type: [Number, String],
      default: 200
    },
    h: {
      type: [Number, String],
      default: 200
    },
    minw: {
      type: Number,
      default: 0,
      validator: function(val) {
        return val >= 0
      }
    },
    minh: {
      type: Number,
      default: 0,
      validator: function(val) {
        return val >= 0
      }
    },
    r: {
      type: [Number, String],
      default: 0
    },
    x: {
      type: [Number, String],
      default: 0
    },
    y: {
      type: [Number, String],
      default: 0
    },
    z: {
      type: [String, Number],
      default: "auto",
      validator: function(val) {
        let valid = typeof val === "string" ? val === "auto" : val >= 0
        return valid
      }
    },
    handles: {
      type: Array,
      default: function() {
        return ["tl", "tm", "tr", "mr", "br", "bm", "bl", "ml", "rot"]
      }
    },
    cursors: {
      type: Array,
      default: function() {
        return [
          "nw-resize",
          "n-resize",
          "ne-resize",
          "e-resize",
          "se-resize",
          "s-resize",
          "sw-resize",
          "w-resize"
        ]
      }
    },
    dragHandle: {
      type: String,
      default: null
    },
    dragCancel: {
      type: String,
      default: null
    },
    axis: {
      type: String,
      default: "both",
      validator: function(val) {
        return ["x", "y", "both"].indexOf(val) !== -1
      }
    },
    grid: {
      type: Array,
      default: function() {
        return [1, 1]
      }
    },
    parent: {
      type: Boolean,
      default: false
    },
    maximize: {
      type: Boolean,
      default: false
    },
    deselectCancel: {
      type: String,
      default: null
    }
  },

  created() {
    this.parentX = 0
    this.parentW = 9999
    this.parentY = 0
    this.parentH = 9999

    this.lastMouseX = 0
    this.lastMouseY = 0

    this.elmX = 0
    this.elmY = 0

    this.elmW = 0
    this.elmH = 0

    this.lastCenterX = 0
    this.lastCenterY = 0
    this.lastElmX = 0
    this.lastElmY = 0
    this.lastElmW = 0
    this.lastElmH = 0

    this.fixedXName = ""
    this.fixedYName = ""
    this.fixedX = 0
    this.fixedY = 0
  },
  mounted() {
    this.elBase = document.querySelector(".view-con")
    this.leftEl = document.querySelector(".left-con")

    this.elBase.addEventListener("mousemove", this.handleMove, true)
    this.elBase.addEventListener("mousedown", this.deselect, true)
    this.elBase.addEventListener("mouseup", this.handleUp, true)

    // touch events bindings
    this.elBase.addEventListener("touchmove", this.handleMove, true)
    this.elBase.addEventListener("touchend touchcancel", this.deselect, true)
    this.elBase.addEventListener("touchstart", this.handleUp, true)

    this.elmX = parseInt(this.$el.style.left)
    this.elmY = parseInt(this.$el.style.top)
    this.elmW = this.$el.offsetWidth || this.$el.clientWidth
    this.elmH = this.$el.offsetHeight || this.$el.clientHeight

    this.leftEl.addEventListener("mousedown", this.deselect, true)
    // this.reviewDimensions() // 先注释掉
  },
  beforeDestroy() {
    this.elBase.removeEventListener("mousemove", this.handleMove, true)
    this.elBase.removeEventListener("mousedown", this.deselect, true)
    this.elBase.removeEventListener("mouseup", this.handleUp, true)

    // touch events bindings removed
    this.elBase.removeEventListener("touchmove", this.handleMove, true)
    this.elBase.removeEventListener("touchend touchcancel", this.deselect, true)
    this.elBase.removeEventListener("touchstart", this.handleUp, true)

    this.leftEl.removeEventListener("mousedown", this.deselect, true)
  },

  data() {
    return {
      top: this.y,
      left: this.x,
      width: this.w,
      height: this.h,
      rotate: this.r,
      resizing: false,
      dragging: false,
      rotating: false,
      enabled: this.active,
      handle: null,
      zIndex: this.z
    }
  },

  methods: {
    reviewDimensions() {
      if (this.minw > this.w) this.width = this.minw

      if (this.minh > this.h) this.height = this.minh

      if (this.parent) {
        const parentW = parseInt(this.$el.parentNode.clientWidth, 10)
        const parentH = parseInt(this.$el.parentNode.clientHeight, 10)

        this.parentW = parentW
        this.parentH = parentH

        if (this.w > this.parentW) this.width = parentW

        if (this.h > this.parentH) this.height = parentH

        if (this.x + this.w > this.parentW) this.width = parentW - this.x

        if (this.y + this.h > this.parentH) this.height = parentH - this.y
      }

      this.elmW = this.width
      this.elmH = this.height

      // this.$emit("resizing", this.left, this.top, this.width, this.height) // 先注释掉
    },
    elmDown(e) {
      const target = e.target || e.srcElement
      if (this.$el.contains(target)) {
        if (
          (this.dragHandle &&
            !matchesSelectorToParentElements(
              target,
              this.dragHandle,
              this.$el
            )) ||
          (this.dragCancel &&
            matchesSelectorToParentElements(target, this.dragCancel, this.$el))
        ) {
          return
        }
        if (!this.enabled) {
          this.enabled = true
          this.$emit("activated")
          this.$emit("update:active", true)
        }
        this.reviewDimensions()
        this.lastElmX = this.elmX
        this.lastElmY = this.elmY
        this.lastElmW = this.elmW
        this.lastElmH = this.elmH
        if (this.draggable) {
          this.$emit("dragstart", this.left, this.top)
          this.dragging = true
        }
      }
    },
    deselect(e) {
      let { x: mouseX, y: mouseY } = this.getMouseCoordinate(e)
      this.startDownX = mouseX
      this.startDownY = mouseY

      this.lastMouseX = mouseX
      this.lastMouseY = mouseY

      const target = e.target || e.srcElement
      const regex = new RegExp("handle-([trmbl]{2})", "")

      if (
        this.deselectCancel &&
        matchesSelectorToParentElements(target, this.deselectCancel)
      ) {
        return
      }
      const selectWidgetsCount = this.$store.getters.selectWidgets.length
      // 多选控件 激活
      if (
        (!this.$el.contains(target) &&
          !regex.test(target.className) &&
          selectWidgetsCount == 1) ||
        (selectWidgetsCount > 1 && !target.classList.contains("group-item") && !target.classList.contains("my-drag"))
      ) {
        if (this.enabled) {
          console.log("abb---",e)
          this.enabled = false
          this.$emit("deactivated")
          this.$emit("update:active", false)
        }
      }
    },
    handleResizeDown(handle) {
      let fixed = {
        x: handle[1] === "l" ? "right" : "left",
        y: handle[0] === "t" ? "bottom" : "top"
      }

      let rect = {
        top: this.top,
        right: this.left + this.width,
        bottom: this.top + this.height,
        left: this.left
      }
      this.$emit("resizestart", this.left, this.top, this.width, this.height)
      let fixedCoordinate = this.rotatedPoint(rect, this.rotate, fixed)

      this.fixedXName = fixed.x
      this.fixedYName = fixed.y

      this.fixedX = fixedCoordinate.x
      this.fixedY = fixedCoordinate.y

      this.lastElmX = this.elmX
      this.lastElmY = this.elmY
      this.lastElmW = this.elmW
      this.lastElmH = this.elmH

      this.resizing = true
    },
    handleRotateDown() {
      let { top, left, width, height } = this.$el.getBoundingClientRect()
      this.lastCenterX = window.pageXOffset + left + width / 2
      this.lastCenterY = window.pageYOffset + top + height / 2
      this.rotating = true
    },
    handleDown(handle, e) {
      this.handle = handle

      if (e.stopPropagation) e.stopPropagation()
      if (e.preventDefault) e.preventDefault()

      if (handle === "rot") {
        this.handleRotateDown(handle, e)
      } else {
        this.handleResizeDown(handle, e)
      }
    },
    handleMove(e) {
      if (!this.enabled) {
        return
      }
      let { x: mouseX, y: mouseY } = this.getMouseCoordinate(e)
      if (this.resizing) {
        let rotate = this.rotate
        let width = mouseX - this.lastMouseX
        let height = mouseY - this.lastMouseY
        let angle = this.getAngle(width, height)
        let c = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2))
        let rad = (Math.PI / 180) * (angle - rotate)
        let diffY = Math.round(Math.sin(rad) * c)
        let diffX = Math.round(Math.cos(rad) * c)
        this.elmX = this.lastElmX
        this.elmY = this.lastElmY
        this.elmW = this.lastElmW
        this.elmH = this.lastElmH

        let [handleY, handleX] = this.handle

        if (handleX !== "m") {
          this.elmW += diffX * (handleX === "r" ? 1 : -1)
        }

        if (handleY !== "m") {
          this.elmH += diffY * (handleY === "b" ? 1 : -1)
        }

        if (this.elmW < this.minw) {
          this.elmW = this.minw
        }

        if (this.elmH < this.minh) {
          this.elmH = this.minh
        }

        this.fixedTo()

        if (this.parent) {
          let change = false

          if (this.elmX < this.parentX) {
            this.elmW -= Math.round(this.parentX - this.elmX)
            change = true
          }

          if (this.elmY < this.parentY) {
            this.elmH -= Math.round(this.parentY - this.elmY)
            change = true
          }

          if (this.elmX + this.elmW > this.parentW) {
            this.elmW = Math.round(this.parentW - this.elmX)
            change = true
          }

          if (this.elmY + this.elmH > this.parentH) {
            this.elmH = Math.round(this.parentH - this.elmY)
            change = true
          }

          if (change) {
            this.fixedTo()
          }
        }

        this.left = Math.round(this.elmX / this.grid[0]) * this.grid[0]
        this.top = Math.round(this.elmY / this.grid[1]) * this.grid[1]
        this.width = Math.round(this.elmW / this.grid[0]) * this.grid[0]
        this.height = Math.round(this.elmH / this.grid[1]) * this.grid[1]
        this.$emit("resizing", this.left, this.top, this.width, this.height)
      } else if (this.dragging) {
        this.elmX = this.lastElmX
        this.elmY = this.lastElmY
        this.elmW = this.lastElmW
        this.elmH = this.lastElmH
        let diffX = mouseX - this.lastMouseX
        let diffY = mouseY - this.lastMouseY
        let dX = diffX
        let dY = diffY

        if (this.parent) {
          if (this.elmX + dX < this.parentX) {
            diffX = this.parentX - this.elmX
          } else if (this.elmX + this.elmW + dX > this.parentW) {
            diffX = this.parentW - this.elmX - this.elmW
          }
          if (this.elmY + dY < this.parentY) {
            this.mouseOffY = dY - (diffY = this.parentY - this.elmY)
          } else if (this.elmY + this.elmH + dY > this.parentH) {
            this.mouseOffY = dY - (diffY = this.parentH - this.elmY - this.elmH)
          }
        }
        this.elmX += diffX
        this.elmY += diffY
        if (this.axis === "x" || this.axis === "both") {
          this.left = Math.round(this.elmX / this.grid[0]) * this.grid[0]
        }
        if (this.axis === "y" || this.axis === "both") {
          this.top = Math.round(this.elmY / this.grid[1]) * this.grid[1]
        }
        this.$emit("dragging", this.left, this.top)
      } else if (this.rotating) {
        let y = mouseY - this.lastCenterY
        let x = mouseX - this.lastCenterX
        this.rotate = (this.getAngle(x, y) + 90) % 360
        this.$emit("rotating", this.rotate)
      }
    },
    handleUp(e) {
      let { x: mouseX, y: mouseY } = this.getMouseCoordinate(e)
      if (
        Math.abs(mouseX - this.startDownX) < 1 ||
        Math.abs(mouseY - this.startDownY) < 1
      ) {
        // 鼠标没有进行移动
        const target = e.target || e.srcElement
        const regex = new RegExp("handle-([trmbl]{2})", "")
         const selectWidgetsCount = this.$store.getters.selectWidgets.length
        let flag = selectWidgetsCount==1 && !this.$el.contains(target) && !regex.test(target.className)
          || selectWidgetsCount>1 && !target.classList.contains("group-item") && !target.classList.contains("my-drag")
        if (flag) {
          if (this.enabled) {
            this.enabled = false
            this.$emit("deactivated")
            this.$emit("update:active", false)
          }
        }
      }
      this.lastMouseX = mouseX
      this.lastMouseY = mouseY

      this.handle = null
      if (this.resizing) {
        this.resizing = false
        this.$emit("resizestop", this.left, this.top, this.width, this.height)
      } else if (this.dragging) {
        this.dragging = false
        this.$emit("dragstop", this.left, this.top)
      } else if (this.rotating) {
        this.rotating = false
        this.$emit("rotatestop", this.rotate)
      }

      this.elmX = this.left
      this.elmY = this.top
    },
    getMouseCoordinate(e) {
      if (e.type.indexOf("touch") !== -1) {
        return {
          x: e.changedTouches[0].clientX,
          y: e.changedTouches[0].clientY
        }
      } else {
        return {
          x: e.pageX || e.clientX + document.documentElement.scrollLeft,
          y: e.pageY || e.clientY + document.documentElement.scrollTop
        }
      }
    },
    fixedTo() {
      let rect = {
        top: this.elmY,
        right: this.elmX + this.elmW,
        bottom: this.elmY + this.elmH,
        left: this.elmX
      }

      let fixed = {
        x: this.fixedXName,
        y: this.fixedYName
      }

      let { x: fixedX, y: fixedY } = this.rotatedPoint(rect, this.rotate, fixed)

      let dX = Math.round(this.fixedX - fixedX)
      let dY = Math.round(this.fixedY - fixedY)

      this.elmX += dX
      this.elmY += dY
    },
    rotatedPoint(rect, rotate, point) {
      let { top, right, bottom, left } = rect

      let rad = (Math.PI / 180) * rotate
      let cos = Math.cos(rad)
      let sin = Math.sin(rad)

      let originX = (right - left + 1) / 2 + left
      let originY = (bottom - top + 1) / 2 + top

      let x = rect[point.x]
      let y = rect[point.y]

      x -= originX
      y -= originY

      return {
        x: x * cos - y * sin + originX,
        y: x * sin + y * cos + originY
      }
    },
    getAngle(x, y) {
      let theta = Math.atan2(y, x) // range (-PI, PI]
      theta = Math.round((180 / Math.PI) * theta) // rads to degs, range (-180, 180]

      if (theta < 0) theta = 360 + theta // range [0, 360)
      return theta
    }
  },

  computed: {
    style() {
      return {
        top: this.top + "px",
        left: this.left + "px",
        width: this.width + "px",
        height: this.height + "px",
        transform: "rotate(" + this.rotate + "deg)",
        zIndex: this.zIndex
      }
    },
    cursorStyle() {
      const cursorStyleArray = this.cursors

      const ARR_LENGTH = 8
      const STEP = 45

      let startIndex = 0
      let rotate = this.rotate

      if (rotate) {
        startIndex = Math.floor(rotate / STEP)
        if (rotate % STEP > STEP / 2) {
          startIndex += 1
        }
      }

      if (startIndex > 1) {
        const len = ARR_LENGTH - startIndex
        return cursorStyleArray
          .slice(startIndex, startIndex + len)
          .concat(cursorStyleArray.slice(0, startIndex))
      }

      return cursorStyleArray
    }
  },

  watch: {
    r(val) {
      if (val >= 0) {
        this.rotate = val % 360
      }
    },
    w(val) {
      this.width = val
    },
    h(val) {
      this.height = val
    },
    x(val) {
      this.left = val
      this.$nextTick(() => {
        // 只是通过mousedown来重新设置elmX，回撤时候，x变了，但是没有监听到，这个地方重新设置下
        this.elmX = parseInt(this.$el.style.left)
      })
    },
    y(val) {
      this.top = val
      this.$nextTick(() => {
        this.elmY = parseInt(this.$el.style.top)
      })
    },
    active(val) {
      this.enabled = val
    },
    z(val) {
      if (val >= 0 || val === "auto") {
        this.zIndex = val
      }
    }
  }
}
</script>

<style scoped>
.vdrr {
  position: absolute;
  box-sizing: border-box;
}
.vdrr.dragging {
  user-select: none;
}
.vdrr.active:before {
  content: "";
  position: absolute;
  top: -1px;
  right: -1px;
  bottom: -1px;
  left: -1px;
  border: 1px dashed #298df8;
}
.vdrr.active {
  z-index: 1 !important;
}
.handle {
  box-sizing: border-box;
  display: none;
  position: absolute;
  width: 10px;
  height: 10px;
  font-size: 1px;
  border-radius: 5px;
  background: #eee;
  border: 1px solid #1baee1;
  z-index: 999999;
}
.handle-tl {
  top: -5px;
  left: -5px;
}
.handle-tm {
  top: -5px;
  left: 50%;
  margin-left: -5px;
}
.handle-tr {
  top: -5px;
  right: -5px;
}
.handle-ml {
  top: 50%;
  margin-top: -5px;
  left: -5px;
}
.handle-mr {
  top: 50%;
  margin-top: -5px;
  right: -5px;
}
.handle-bl {
  bottom: -5px;
  left: -5px;
}
.handle-bm {
  bottom: -5px;
  left: 50%;
  margin-left: -5px;
}
.handle-br {
  bottom: -5px;
  right: -5px;
}
.handle-rot {
  position: absolute;
  top: 0;
  left: 50%;
  margin-top: -20px;
  width: 10px;
  height: 10px;
  transform: translate(-50%, 0);
}
.handle-rot:before {
  content: "";
  position: absolute;
  top: 9px;
  left: 50%;
  width: 0;
  height: 6px;
  border-left: 1px solid #1baee1;
  transform: translate(-50%, 0);
}
@media only screen and (max-width: 768px) {
  /* For mobile phones: */
  [class*="handle-"]:before {
    content: "";
    left: -10px;
    right: -10px;
    bottom: -10px;
    top: -10px;
    position: absolute;
  }
}
</style>
